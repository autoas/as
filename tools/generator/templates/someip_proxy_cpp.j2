/**
 * SSAS - Simple Smart Automotive Software
 * Copyright (C) 2021-{{ now.year }} Parai Wang <parai@foxmail.com>
 *
 * Generated at {{ now.strftime("%c") }}
 */



/* ================================ [ INCLUDES  ] ============================================== */
#include "{{ service_name }}Proxy.hpp"
#include "Std_Types.h"
#include "Std_Debug.h"
#include "Sd.h"
#include "SomeIp_Cfg.h"
#include "Sd_Cfg.h"
namespace ara {
namespace com {
namespace {{ service_name }} {
/* ================================ [ MACROS    ] ============================================== */
#define AS_LOG_{{ toMacro(service_name) }} 0
#define AS_LOG_{{ toMacro(service_name) }}_E 2
#define SOMEIP_SF_MAX 1396
/* ================================ [ TYPES     ] ============================================== */
/* ================================ [ CLASS     ] ============================================== */
class {{ service_name }}Manager {
public:
  {{ service_name }}Manager() {
{% for eg in service.get('event-groups', []) %}
    m_eventGroupInfoMap[SD_CONSUMED_EVENT_GROUP_{{ toMacro(service_name) }}_{{ toMacro(eg['name']) }}] = {
      0,
      SubscriptionState::kNotSubscribed,
    };
{% endfor %}
  }

  ~{{ service_name }}Manager() {
  }

{% for eg in service.get('event-groups', []) %}
{% for event in eg['events'] %}
{% if 'for' not in event %}
  void Register(events::{{ event['name'] }} *h{{ event['name'] }}) {
    std::lock_guard<std::mutex> lck(m_lock);
    if (nullptr == m_h{{ event['name'] }}) {
      m_h{{ event['name'] }} = h{{ event['name'] }};
    } else {
      throw std::runtime_error("{{ event['name'] }} already registerred");
    }
  }

  void UnRegister(events::{{ event['name'] }} *h{{ event['name'] }}) {
    std::lock_guard<std::mutex> lck(m_lock);
    if (h{{ event['name'] }} == m_h{{ event['name'] }}) {
      m_h{{ event['name'] }} = nullptr;
    } else {
      throw std::runtime_error("incorrect {{ event['name'] }} when do unregister");
    }
  }
  
  void On{{ event['name'] }}(const events::{{ event['name'] }}::SampleType &sample) {
    if (nullptr != m_h{{ event['name'] }}) {
      m_h{{ event['name'] }}->OnEvent(sample);
    }
  }

  void On{{ event['name'] }}SubscribeAck(bool isSubscribe) {
    if (nullptr != m_h{{ event['name'] }}) {
      m_h{{ event['name'] }}->OnSubscribeAck(isSubscribe);
    }
  }

{% endif %}
{% endfor %}
{% endfor %}

{% for field in service.get('fields', []) %}
  void Register(fields::{{ field['name'] }} *h{{ field['name'] }}) {
    std::lock_guard<std::mutex> lck(m_lock);
    if (nullptr == m_h{{ field['name'] }}) {
      m_h{{ field['name'] }} = h{{ field['name'] }};
    } else {
      throw std::runtime_error("{{ field['name'] }} already registerred");
    }
  }

  void UnRegister(fields::{{ field['name'] }} *h{{ field['name'] }}) {
    std::lock_guard<std::mutex> lck(m_lock);
    if (h{{ field['name'] }} == m_h{{ field['name'] }}) {
      m_h{{ field['name'] }} = nullptr;
    } else {
      throw std::runtime_error("incorrect {{ field['name'] }} when do unregister");
    }
  }

{% if 'get' in field %}
  Std_ReturnType OnGet{{ field['name'] }}Response(uint32_t requestId, SomeIp_MessageType* res) {
    Std_ReturnType ret = E_OK;
    if (nullptr != m_h{{ field['name'] }}) {
      ret = m_h{{ field['name'] }}->OnGetResponse(requestId, res);
    } else {
      ret = E_NOT_OK;
    }
    return ret;
  }

  Std_ReturnType OnGet{{ field['name'] }}Error(uint32_t requestId, Std_ReturnType ercd) {
    Std_ReturnType ret = E_OK;
    if (nullptr != m_h{{ field['name'] }}) {
      ret = m_h{{ field['name'] }}->OnGetError(requestId, ercd);
    } else {
      ret = E_NOT_OK;
    }
    return ret;
  }

{% if field.get('tp', False) %}
  Std_ReturnType OnGet{{ field['name'] }}TpCopyRxData(uint32_t requestId, SomeIp_TpMessageType *msg) {
    Std_ReturnType ret = E_OK;
    if (nullptr != m_h{{ field['name'] }}) {
      ret = m_h{{ field['name'] }}->OnGetTpCopyRxData(requestId, msg);
    } else {
      ret = E_NOT_OK;
    }
    return ret;
  }

  Std_ReturnType OnGet{{ field['name'] }}TpCopyTxData(uint32_t requestId, SomeIp_TpMessageType *msg) {
    Std_ReturnType ret = E_OK;
    if (nullptr != m_h{{ field['name'] }}) {
      ret = m_h{{ field['name'] }}->OnGetTpCopyTxData(requestId, msg);
    } else {
      ret = E_NOT_OK;
    }
    return ret;
  }

{% endif %}
{% endif %}

{% if 'set' in field %}
  Std_ReturnType OnSet{{ field['name'] }}Response(uint32_t requestId, SomeIp_MessageType* res) {
    Std_ReturnType ret = E_OK;
    if (nullptr != m_h{{ field['name'] }}) {
      ret = m_h{{ field['name'] }}->OnSetResponse(requestId, res);
    } else {
      ret = E_NOT_OK;
    }
    return ret;
  }

  Std_ReturnType OnSet{{ field['name'] }}Error(uint32_t requestId, Std_ReturnType ercd) {
    Std_ReturnType ret = E_OK;
    if (nullptr != m_h{{ field['name'] }}) {
      ret = m_h{{ field['name'] }}->OnSetError(requestId, ercd);
    } else {
      ret = E_NOT_OK;
    }
    return ret;
  }

{% if field.get('tp', False) %}
  Std_ReturnType OnSet{{ field['name'] }}TpCopyRxData(uint32_t requestId, SomeIp_TpMessageType *msg) {
    Std_ReturnType ret = E_OK;
    if (nullptr != m_h{{ field['name'] }}) {
      ret = m_h{{ field['name'] }}->OnSetTpCopyRxData(requestId, msg);
    } else {
      ret = E_NOT_OK;
    }
    return ret;
  }

  Std_ReturnType OnSet{{ field['name'] }}TpCopyTxData(uint32_t requestId, SomeIp_TpMessageType *msg) {
    Std_ReturnType ret = E_OK;
    if (nullptr != m_h{{ field['name'] }}) {
      ret = m_h{{ field['name'] }}->OnSetTpCopyTxData(requestId, msg);
    } else {
      ret = E_NOT_OK;
    }
    return ret;
  }

{% endif %}
{% endif %}

{% if 'event' in field %}
  Std_ReturnType On{{ field['name'] }}Notification(uint32_t requestId, SomeIp_MessageType* evt) {
    Std_ReturnType ret = E_OK;
    if (nullptr != m_h{{ field['name'] }}) {
      m_h{{ field['name'] }}->OnNotification(requestId, evt);
    } else {
      ret = E_NOT_OK;
    }
    return ret;
  }

  Std_ReturnType On{{ field['name'] }}SubscribeAck(boolean isSubscribe) {
    Std_ReturnType ret = E_OK;
    if (nullptr != m_h{{ field['name'] }}) {
      m_h{{ field['name'] }}->OnSubscribeAck(isSubscribe);
    } else {
      ret = E_NOT_OK;
    }
    return ret;
  }

{% if field.get('tp', False) %}
  Std_ReturnType On{{ field['name'] }}TpCopyRxData(uint32_t requestId, SomeIp_TpMessageType *msg) {
    Std_ReturnType ret = E_OK;
    if (nullptr != m_h{{ field['name'] }}) {
      ret = m_h{{ field['name'] }}->OnTpCopyRxData(requestId, msg);
    } else {
      ret = E_NOT_OK;
    }
    return ret;
  }

{% endif %}
{% endif %}

{% endfor %}

{% for method in service.get('methods', []) %}
{% if 'for' not in method %}
  void Register(methods::{{ method['name'] }} *h{{ method['name'] }}) {
    std::lock_guard<std::mutex> lck(m_lock);
    if (nullptr == m_h{{ method['name'] }}) {
      m_h{{ method['name'] }} = h{{ method['name'] }};
    } else {
      throw std::runtime_error("{{ method['name'] }} already registerred");
    }
  }

  void UnRegister(methods::{{ method['name'] }} *h{{ method['name'] }}) {
    std::lock_guard<std::mutex> lck(m_lock);
    if (h{{ method['name'] }} == m_h{{ method['name'] }}) {
      m_h{{ method['name'] }} = nullptr;
    } else {
      throw std::runtime_error("incorrect {{ method['name'] }} when do unregister");
    }
  }

  Std_ReturnType On{{ method['name'] }}Error(uint32_t requestId, Std_ReturnType ercd) {
    Std_ReturnType ret = E_OK;

    if (nullptr != m_h{{ method['name'] }}) {
      m_h{{ method['name'] }}->OnError(requestId, ercd);
    } else {
      ret = E_NOT_OK;
    }

    return ret;
  }

{% if method.get('tp', False) %}
Std_ReturnType On{{ method['name'] }}TpCopyRxData(uint32_t requestId, SomeIp_TpMessageType *msg){
    Std_ReturnType ret = E_OK;

    if (nullptr != m_h{{ method['name'] }}) {
      m_h{{ method['name'] }}->OnTpCopyRxData(requestId, msg);
    } else {
      ret = E_NOT_OK;
    }

    return ret;
  }

Std_ReturnType On{{ method['name'] }}TpCopyTxData(uint32_t requestId, SomeIp_TpMessageType *msg){
  Std_ReturnType ret = E_OK;

  if (nullptr != m_h{{ method['name'] }}) {
    m_h{{ method['name'] }}->OnTpCopyTxData(requestId, msg);
  } else {
    ret = E_NOT_OK;
  }

  return ret;
}
{% endif %}

  Std_ReturnType On{{ method['name'] }}Response(uint32_t requestId, SomeIp_MessageType *res) {
    Std_ReturnType ret = E_OK;

    if (nullptr != m_h{{ method['name'] }}) {
      m_h{{ method['name'] }}->OnResponse(requestId, res);
    } else {
      ret = E_NOT_OK;
    }

    return ret;
  }

{% endif %}
{% endfor %}

  Result<ServiceHandleContainer<{{ service_name }}Proxy::HandleType>>
  FindService(uint16 ClientServiceHandleId) {
    Result<ServiceHandleContainer<{{ service_name }}Proxy::HandleType>> rslt({});
    Std_ReturnType ret;
    ret = Sd_ClientServiceSetState(ClientServiceHandleId, SD_CLIENT_SERVICE_REQUESTED);
    if (E_OK == ret) {
      if (true == m_avaiable) {
        ServiceHandleContainer<{{ service_name }}Proxy::HandleType> shc;
        shc.push_back({{ service_name }}Proxy::HandleType());
        rslt = Result<ServiceHandleContainer<{{ service_name }}Proxy::HandleType>>(shc);
      }
    } else {
      rslt = Result<ServiceHandleContainer<{{ service_name }}Proxy::HandleType>>(ret);
    }

    return rslt;
  }

  Std_ReturnType Subscribe(uint16_t SdConsumedEventGroupHandleId) {
    Std_ReturnType ret = E_OK;

    std::lock_guard<std::mutex> lck(m_lock);
    auto it = m_eventGroupInfoMap.find(SdConsumedEventGroupHandleId);
    if (m_eventGroupInfoMap.end() != it) {
      if (0 == it->second.ref) {
        ret = Sd_ConsumedEventGroupSetState(SdConsumedEventGroupHandleId,
                                            SD_CONSUMED_EVENTGROUP_REQUESTED);
      }
      it->second.ref++;
    } else {
      ret = E_NOT_OK;
    }
    return ret;
  }

  Std_ReturnType Unsubscribe(uint16_t SdConsumedEventGroupHandleId) {
    Std_ReturnType ret = E_OK;
    std::lock_guard<std::mutex> lck(m_lock);
    auto it = m_eventGroupInfoMap.find(SdConsumedEventGroupHandleId);
    if (m_eventGroupInfoMap.end() != it) {
      if (it->second.ref > 0) {
        it->second.ref--;
      }
      if (0 == it->second.ref) {
        ret = Sd_ConsumedEventGroupSetState(SdConsumedEventGroupHandleId,
                                            SD_CONSUMED_EVENTGROUP_RELEASED);
      }
    } else {
      ret = E_NOT_OK;
    }
    return ret;
  }

  SubscriptionState GetSubscriptionState(uint16_t SdConsumedEventGroupHandleId) {
    SubscriptionState state = SubscriptionState::kNotSubscribed;
    Sd_ConsumedEventGroupCurrentStateType ConsumedEventGroupCurrentState;
    Std_ReturnType ret;

    std::lock_guard<std::mutex> lck(m_lock);
    auto it = m_eventGroupInfoMap.find(SdConsumedEventGroupHandleId);
    if (m_eventGroupInfoMap.end() != it) {
      ret = Sd_ConsumedEventGroupGetState(SdConsumedEventGroupHandleId,
                                          &ConsumedEventGroupCurrentState);
      if (E_OK == ret) {
        if (SD_CONSUMED_EVENTGROUP_AVAILABLE == ConsumedEventGroupCurrentState) {
          state = SubscriptionState::kSubscribed;
        } else {
          if (it->second.ref > 0) {
            state = SubscriptionState::kSubscriptionPending;
          }
        }
      }
    }

    return state;
  }

  void OnAvailability(boolean isAvailable) {
    m_avaiable = isAvailable;
  }

  static std::shared_ptr<{{ service_name }}Manager> GetInstance();

private:
  struct EventGroupInfo {
    int ref;
    SubscriptionState state;
  };

private:
  bool m_avaiable = false;
  std::mutex m_lock;
  std::unordered_map<uint16_t, EventGroupInfo> m_eventGroupInfoMap;

{% for eg in service.get('event-groups', []) %}
{% for event in eg['events'] %}
{% if 'for' not in event %}
  events::{{ event['name'] }} *m_h{{ event['name'] }} = nullptr;
{% endif %}
{% endfor %}
{% endfor %}

{% for field in service.get('fields', []) %}
  fields::{{ field['name'] }} *m_h{{ field['name'] }} = nullptr;
{% endfor %}

{% for method in service.get('methods', []) %}
{% if 'for' not in method %}
  methods::{{ method['name'] }} *m_h{{ method['name'] }} = nullptr;
{% endif %}
{% endfor %}

private:
  static std::mutex s_lock;
  static std::shared_ptr<{{ service_name }}Manager> s_{{ service_name }}Manager;
};

/* ================================ [ DECLARES  ] ============================================== */
/* ================================ [ DATAS     ] ============================================== */
std::mutex {{ service_name }}Manager::s_lock;
std::shared_ptr<{{ service_name }}Manager> {{ service_name }}Manager::s_{{ service_name }}Manager;
/* ================================ [ LOCALS    ] ============================================== */
/* ================================ [ FUNCTIONS ] ============================================== */
std::shared_ptr<{{ service_name }}Manager> {{ service_name }}Manager::GetInstance() {

  std::lock_guard<std::mutex> lck(s_lock);
  if (nullptr == s_{{ service_name }}Manager) {
    s_{{ service_name }}Manager = std::make_shared<{{ service_name }}Manager>();
  }

  return s_{{ service_name }}Manager;
}

namespace events {
{% for eg in service.get('event-groups', []) %}
{% for event in eg['events'] %}
{% if 'for' not in event %}

{{ event['name'] }}::{{ event['name'] }}() {
  {{ service_name }}Manager::GetInstance()->Register(this);
}

{{ event['name'] }}::~{{ event['name'] }}() {
  {{ service_name }}Manager::GetInstance()->UnRegister(this);
}

Result<void> {{ event['name'] }}::Subscribe(size_t maxSampleCount) {
  Result<void> rslt(0);
  Std_ReturnType ret;

  ret = {{ service_name }}Manager::GetInstance()->Subscribe(SD_CONSUMED_EVENT_GROUP_{{ toMacro(service_name) }}_{{ toMacro(eg['name']) }});
  if (E_OK == ret) {
    m_maxSampleCount = maxSampleCount;
  } else {
    rslt = Result<void>(ret);
  }
  return rslt;
}

void {{ event['name'] }}::Unsubscribe() {
  (void){{ service_name }}Manager::GetInstance()->Unsubscribe(
    SD_CONSUMED_EVENT_GROUP_{{ toMacro(service_name) }}_{{ toMacro(eg['name']) }});
}

SubscriptionState {{ event['name'] }}::GetSubscriptionState() const {
  return {{ service_name }}Manager::GetInstance()->GetSubscriptionState(
    SD_CONSUMED_EVENT_GROUP_{{ toMacro(service_name) }}_{{ toMacro(eg['name']) }});
}

void {{ event['name'] }}::OnEvent(const SampleType &sample) {
  SamplePtr<SampleType> samplePtr(new SampleType);
  *samplePtr = sample;
  m_lastNSamples.push_back(std::move(samplePtr));
  if (m_lastNSamples.size() > m_maxSampleCount) {
    m_lastNSamples.pop_front();
  }
  if (nullptr != m_evtRxHandler) {
    m_evtRxHandler();
  }
}

void {{ event['name'] }}::OnSubscribeAck(bool isSubscribe) {
  if (nullptr != m_stateChgHandler) {
    if (true == isSubscribe) {
      m_stateChgHandler(SubscriptionState::kSubscribed);
    } else {
      m_stateChgHandler(SubscriptionState::kNotSubscribed);
    }
  }
}

{% endif %}
{% endfor %}
{% endfor %}
} // namespace events

namespace fields {
{% for field in service.get('fields', []) %}

{{ field['name'] }}::{{ field['name'] }}() {
  {{ service_name }}Manager::GetInstance()->Register(this);
}

{{ field['name'] }}::~{{ field['name'] }}() {
  {{ service_name }}Manager::GetInstance()->UnRegister(this);
}

{% if 'get' in field %}

ara::core::Future<{{ field['name'] }}::FieldType> {{ field['name'] }}::Get() {
  ara::core::Future<FieldType> future;
  if (nullptr == m_promiseGet) {
    m_promiseGet = std::make_shared<Promise<FieldType>>();
    future = m_promiseGet->get_future();
    uint32_t requestId = ((uint32_t)SOMEIP_TX_METHOD_{{ toMacro(service_name) }}_GET_{{ toMacro(field['name']) }} << 16) + 0;
    Std_ReturnType ret = SomeIp_Request(requestId, nullptr, 0);
    if (E_OK != ret) {
      m_promiseGet->SetError(ret);
      m_promiseGet = nullptr;
    }
  } else {
    Promise<FieldType> promise;
    future = promise.get_future();
    promise.SetError(-EBUSY);
  }
  return future;
}

Std_ReturnType {{ field['name'] }}::OnGetResponse(uint32_t requestId, SomeIp_MessageType* res) {
  Std_ReturnType ret = E_OK;
  int32_t serializedSize;
  if (nullptr != m_promiseGet) {
    serializedSize = {{ SomeIpXfDecode(field, allStructs, 'res->data', 'res->length', 'm_fieldGet') }};
    if (serializedSize > 0) {
      m_promiseGet->set_value(m_fieldGet);
    } else {
      ret = E_NOT_OK;
      m_promiseGet->SetError(-EINVAL);
    }
    m_promiseGet = nullptr;
  } else {
    ret = E_NOT_OK;
  }
  return ret;
}

Std_ReturnType {{ field['name'] }}::OnGetError(uint32_t requestId, Std_ReturnType ercd) {
  Std_ReturnType ret = E_OK;
  if (nullptr != m_promiseGet) {
    m_promiseGet->SetError(ercd);
    m_promiseGet = nullptr;
  } else {
    ret = E_NOT_OK;
  }
  return ret;
}

{% if field.get('tp', False) %}

Std_ReturnType {{ field['name'] }}::OnGetTpCopyRxData(uint32_t requestId, SomeIp_TpMessageType *msg) {
  Std_ReturnType ret = E_OK;
  if ((NULL != msg) && ((msg->offset + msg->length)) <= sizeof(m_responseGet)) {
    memcpy(&m_responseGet[msg->offset], msg->data, msg->length);
    if (false == msg->moreSegmentsFlag) {
      msg->data = m_responseGet;
    }
  } else {
    ret = E_NOT_OK;
  }
  return ret;
}

Std_ReturnType {{ field['name'] }}::OnGetTpCopyTxData(uint32_t requestId, SomeIp_TpMessageType *msg) {
  Std_ReturnType ret = E_NOT_OK;
  /* never used for get */
  return ret;
}

{% endif %}
{% endif %}

{% if 'set' in field %}

ara::core::Future<{{ field['name'] }}::FieldType> {{ field['name'] }}::Set(const {{ field['name'] }}::FieldType& value) {
  ara::core::Future<FieldType> future;
  int32_t serializedSize;
  if ((nullptr == m_promiseSet){% if field.get('tp', False) %} && (false == m_requestSetInUse){% endif %}) {
    m_promiseSet = std::make_shared<Promise<FieldType>>();
    future = m_promiseSet->get_future();
    serializedSize = {{ SomeIpXfEncode(field, allStructs, '&m_requestSet[20]', 'sizeof(m_requestSet)-20', 'value') }};
    if (serializedSize > 0) {
      uint32_t requestId = ((uint32_t)SOMEIP_TX_METHOD_{{ toMacro(service_name) }}_SET_{{ toMacro(field['name']) }} << 16) + 0;
      Std_ReturnType ret = SomeIp_Request(requestId, &m_requestSet[20], serializedSize);
      if (E_OK != ret) {
        m_promiseSet->SetError(ret);
        m_promiseSet = nullptr;
      } else {
{% if field.get('tp', False) %}
        if (serializedSize > SOMEIP_SF_MAX) {
          m_requestSetInUse = true;
        }
{% endif %}
      }
    } else {
      m_promiseSet->SetError(-EINVAL);
      m_promiseSet = nullptr;
    }
  } else {
    Promise<FieldType> promise;
    future = promise.get_future();
    promise.SetError(-EBUSY);
  }
  return future;
}

Std_ReturnType {{ field['name'] }}::OnSetResponse(uint32_t requestId, SomeIp_MessageType* res) {
  Std_ReturnType ret = E_OK;
  int32_t serializedSize;
  if (nullptr != m_promiseSet) {
    serializedSize = {{ SomeIpXfDecode(field, allStructs, 'res->data', 'res->length', 'm_fieldSet') }};
    if (serializedSize > 0) {
      m_promiseSet->set_value(m_fieldSet);
    } else {
      ret = E_NOT_OK;
      m_promiseSet->SetError(-EINVAL);
    }
    m_promiseSet = nullptr;
{% if field.get('tp', False) %}
    m_requestSetInUse = false;
{% endif %}
  } else {
    ret = E_NOT_OK;
  }
  return ret;
}

Std_ReturnType {{ field['name'] }}::OnSetError(uint32_t requestId, Std_ReturnType ercd) {
  Std_ReturnType ret = E_OK;
  if (nullptr != m_promiseSet) {
    m_promiseSet->SetError(ercd);
    m_promiseSet = nullptr;
{% if field.get('tp', False) %}
    m_requestSetInUse = false;
{% endif %}
  } else {
    ret = E_NOT_OK;
  }
  return ret;
}

{% if field.get('tp', False) %}

Std_ReturnType {{ field['name'] }}::OnSetTpCopyRxData(uint32_t requestId, SomeIp_TpMessageType *msg) {
  Std_ReturnType ret = E_OK;
  if ((NULL != msg) && ((msg->offset + msg->length)) <= sizeof(m_responseSet)) {
    memcpy(&m_responseSet[msg->offset], msg->data, msg->length);
    if (false == msg->moreSegmentsFlag) {
      msg->data = m_responseSet;
    }
  } else {
    ret = E_NOT_OK;
  }
  return ret;
}

Std_ReturnType {{ field['name'] }}::OnSetTpCopyTxData(uint32_t requestId, SomeIp_TpMessageType *msg) {
  Std_ReturnType ret = E_OK;
  if ((NULL != msg) && ((msg->offset + msg->length + 20)) <= sizeof(m_requestSet)) {
    msg->data = &m_requestSet[msg->offset + 20];
    if (false == msg->moreSegmentsFlag) {
      m_requestSetInUse = false;
    }
  } else {
    ret = E_NOT_OK;
    m_requestSetInUse = false;
  }
  return ret;
}

{% endif %}
{% endif %}

{% if 'event' in field %}

ara::core::Result<void> {{ field['name'] }}::Subscribe(size_t maxSampleCount) {
  Result<void> rslt(0);
  Std_ReturnType ret;

  ret = {{ service_name }}Manager::GetInstance()->Subscribe(SD_CONSUMED_EVENT_GROUP_{{ toMacro(service_name) }}_{{ toMacro(field['event']['groupName']) }});
  if (E_OK == ret) {
    m_maxSampleCount = maxSampleCount;
  } else {
    rslt = Result<void>(ret);
  }
  return rslt;
}

void {{ field['name'] }}::Unsubscribe() {
  (void){{ service_name }}Manager::GetInstance()->Unsubscribe(
    SD_CONSUMED_EVENT_GROUP_{{ toMacro(service_name) }}_{{ toMacro(field['event']['groupName']) }});
}

SubscriptionState {{ field['name'] }}::GetSubscriptionState() const {
  return {{ service_name }}Manager::GetInstance()->GetSubscriptionState(
    SD_CONSUMED_EVENT_GROUP_{{ toMacro(service_name) }}_{{ toMacro(field['event']['groupName']) }});
}

void {{ field['name'] }}::OnSubscribeAck(bool isSubscribe) {
  if (nullptr != m_stateChgHandler) {
    if (true == isSubscribe) {
      m_stateChgHandler(SubscriptionState::kSubscribed);
    } else {
      m_stateChgHandler(SubscriptionState::kNotSubscribed);
    }
  }
}

ara::core::Result<void> {{ field['name'] }}::SetReceiveHandler(ara::com::EventReceiveHandler handler) {
  m_evtRxHandler = handler;
  return ara::core::Result<void>(0);
}

ara::core::Result<void> {{ field['name'] }}::UnsetReceiveHandler() {
  m_evtRxHandler = nullptr;
  return ara::core::Result<void>(0);
}

ara::core::Result<void> {{ field['name'] }}::SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler) {
  m_stateChgHandler = handler;
  return ara::core::Result<void>(0);
}

void {{ field['name'] }}::UnsetSubscriptionStateChangeHandler() {
  m_stateChgHandler = nullptr;
}

void {{ field['name'] }}::OnNotification(uint32_t requestId, SomeIp_MessageType* evt) {
  int32_t serializedSize;
  SamplePtr<FieldType> samplePtr(new FieldType);
  serializedSize = {{ SomeIpXfDecode(field, allStructs, 'evt->data', 'evt->length', '(*samplePtr)') }};
  if (serializedSize > 0) {
    m_lastNSamples.push_back(std::move(samplePtr));
    if (m_lastNSamples.size() > m_maxSampleCount) {
      m_lastNSamples.pop_front();
    }
    if (nullptr != m_evtRxHandler) {
      m_evtRxHandler();
    }
  }
}

{% if field.get('tp', False) %}

Std_ReturnType {{ field['name'] }}::OnTpCopyRxData(uint32_t requestId, SomeIp_TpMessageType *msg) {
  Std_ReturnType ret = E_OK;
  if ((NULL != msg) && ((msg->offset + msg->length) <= sizeof(m_payload))) {
    memcpy(&m_payload[msg->offset], msg->data, msg->length);
    if (FALSE == msg->moreSegmentsFlag) {
      msg->data = m_payload;
    }
  } else {
    ret = E_NOT_OK;
  }
  return ret;
}

{% endif %}
{% endif %}

{% endfor %}
} // namespace fields

namespace methods {
{% for method in service.get('methods', []) %}
{% if 'for' not in method %}

{% if method.get('tp', False) %}

Std_ReturnType {{ method['name'] }}::OnTpCopyRxData(uint32_t requestId, SomeIp_TpMessageType *msg) {
  Std_ReturnType ret = E_OK;
  {% if method.get('return', 'void') != 'void' %}
  if ((NULL != msg) && ((msg->offset + msg->length)) <= sizeof(m_response)) {
    memcpy(&m_response[msg->offset], msg->data, msg->length);
    if (false == msg->moreSegmentsFlag) {
      msg->data = m_response;
    }
  } else {
    ret = E_NOT_OK;
  }
  {% else %}
  ret = E_NOT_OK;
  {% endif %}
  return ret;
}

Std_ReturnType {{ method['name'] }}::OnTpCopyTxData(uint32_t requestId, SomeIp_TpMessageType *msg) {
  Std_ReturnType ret = E_OK;
  if ((NULL != msg) && ((msg->offset + msg->length + 20) <= sizeof(m_request))) {
    msg->data = &m_request[msg->offset + 20];
    if (false == msg->moreSegmentsFlag) {
      m_requestInUse = false;
    }
  } else {
    ret = E_NOT_OK;
    m_requestInUse = false;
  }
  return ret;
}
{% endif %}

{% if method.get('return', 'void') != 'void' %}
ara::core::Future<{{ method['name'] }}::{{ toMethodTypeName(method.get('return', 'void'), method) }}> {{ method['name'] }}::operator()({{ GetArgsList(method, cfg) }}) {
{% else %}
ara::core::Future<{{ toMethodTypeName(method.get('return', 'void'), method) }}> {{ method['name'] }}::operator()({{ GetArgsList(method, cfg) }}) {
{% endif %}
{% if method.get('tp', False) %}
  ara::core::Future<{{ toMethodTypeName(method.get('return', 'void'), method) }}> future;
  int32_t offset = 0;
  int32_t serializedSize;
  if ((false == m_requestInUse) && (nullptr == m_promise)) {
    m_promise = std::make_shared<ara::core::Promise<{{ method.get('return', 'void') }}>>();
    future = m_promise->get_future();
    uint32_t requestId = ((uint32_t)SOMEIP_TX_METHOD_{{ toMacro(service_name) }}_{{ toMacro(method['name']) }} << 16) + 0;
{% if 'args' in method %}
{% set args = GetArgs(cfg, method['args']) %}
{% for arg in args %}
    if ((offset >= 0) && ((int32_t)sizeof(m_request) > (offset + 20))) {
      serializedSize = {{ SomeIpXfEncode(arg, allStructs, '&m_request[offset + 20]', 'sizeof(m_request) - offset - 20', arg['name']) }};
      if (serializedSize > 0) {
        offset += serializedSize;
      } else {
        offset = -ENOSPC;
      }
    }
{% endfor %}
{% endif %}
    if (offset >= 0) {
      Std_ReturnType ret = SomeIp_Request(requestId, &m_request[20], offset);
      if (E_OK != ret) {
        m_promise->SetError(ret);
        m_promise = nullptr;
      } else {
        if (offset > SOMEIP_SF_MAX) {
          m_requestInUse = true;
        }
      }
    } else {
      m_promise->SetError(-EINVAL);
      m_promise = nullptr;
    }
  } else {
    Promise<{{ toMethodTypeName(method.get('return', 'void'), method) }}> promise;
    future = promise.get_future();
    promise.SetError(-EBUSY);
  }

  return future;
{% else %}
  m_promise = std::make_shared<ara::core::Promise<{{ method.get('return', 'void') }}>>();
  ara::core::Future<{{ toMethodTypeName(method.get('return', 'void'), method) }}> future = m_promise->get_future();
  int32_t offset = 0;
  int32_t serializedSize;

  if (nullptr == m_promise) {
    m_promise = std::make_shared<ara::core::Promise<{{ method.get('return', 'void') }}>>();
    future = m_promise->get_future();
    uint32_t requestId = ((uint32_t)SOMEIP_TX_METHOD_{{ toMacro(service_name) }}_{{ toMacro(method['name']) }} << 16) + 0;
{% if 'args' in method %}
{% set args = GetArgs(cfg, method['args']) %}
{% for arg in args %}
    if ((offset >= 0) && ((int32_t)sizeof(m_request) > (offset + 20))) {
      serializedSize = {{ SomeIpXfEncode(arg, allStructs, '&m_request[offset + 20]', 'sizeof(m_request) - offset - 20', arg['name']) }};
      if (serializedSize > 0) {
        offset += serializedSize;
      } else {
        offset = -ENOSPC;
      }
    }
{% endfor %}
{% endif %}
    if (offset >= 0) {
      Std_ReturnType ret = SomeIp_Request(requestId, &m_request[20], offset);
      if (E_OK != ret) {
        m_promise->SetError(ret);
        m_promise = nullptr;
      }
    } else {
      m_promise->SetError(-EINVAL);
      m_promise = nullptr;
    }
  } else {
    Promise<{{ toMethodTypeName(method.get('return', 'void'), method) }}> promise;
    future = promise.get_future();
    promise.SetError(-EBUSY);
  }

  return future;
{% endif %}
}

{{ method['name'] }}::{{ method['name'] }}() {
  {{ service_name }}Manager::GetInstance()->Register(this);
}

{{ method['name'] }}::~{{ method['name'] }}() {
  {{ service_name }}Manager::GetInstance()->UnRegister(this);
}

Std_ReturnType {{ method['name'] }}::OnError(uint32_t requestId, Std_ReturnType ercd) {
  if (nullptr != m_promise) {
    m_promise->SetError(ercd);
    m_promise = nullptr;
  } else {
    ASLOG({{ toMacro(service_name) }}_E, ("no promise for {{ method['name'] }} error %d\n", ercd));
  }
  return E_OK;
}

Std_ReturnType {{ method['name'] }}::OnResponse(uint32_t requestId, SomeIp_MessageType *res) {
  Std_ReturnType ret = E_OK;
  if (nullptr != m_promise) {
    {% if method.get('return', 'void') != 'void' %}
    int32_t serializedSize =
      {{ SomeIpXfDecode(method.get('return', 'void'), allStructs, 'res->data', 'res->length', 'm_' ~ toMethodTypeName(method.get('return', 'void'), method)) }};
    if (serializedSize > 0) {
      m_promise->set_value(m_{{ toMethodTypeName(method.get('return', 'void'), method) }});
    } else {
      ASLOG({{ toMacro(service_name) }}_E, ("malformed {{ method['name'] }} response {{ toMethodTypeName(method.get('return', 'void'), method) }}\n"));
      m_promise->SetError(-EINVAL);
      ret = E_NOT_OK;
    }
    {% else %}
    // Void return type, just set success
    m_promise->SetError(E_OK);
    {% endif %}
    m_promise = nullptr;
  } else {
    ASLOG({{ toMacro(service_name) }}_E, ("no promise for {{ method['name'] }} response\n"));
  }

  return ret;
}
{% endif %}
{% endfor %}

} // namespace methods

{{ service_name }}Proxy::HandleType::HandleType()
  : m_clientId(SOMEIP_CSID_{{ toMacro(service_name) }}), m_serviceId(SD_CLIENT_SERVICE_HANDLE_ID_{{ toMacro(service_name) }}) {
}

{{ service_name }}Proxy::HandleType::~HandleType() {
}

{{ service_name }}Proxy::{{ service_name }}Proxy(HandleType &handle) : m_handle(handle) {
}

Result<ServiceHandleContainer<{{ service_name }}Proxy::HandleType>>
{{ service_name }}Proxy::FindService(InstanceSpecifier instanceSpec) {
  return {{ service_name }}Manager::GetInstance()->FindService(SD_CLIENT_SERVICE_HANDLE_ID_{{ toMacro(service_name) }});
}

} // namespace {{ service_name }}
} // namespace com
} // namespace ara

using namespace ara::com::{{ service_name }};

extern "C" {

void SomeIp_{{ service_name }}_OnAvailability(boolean isAvailable) {
  ASLOG({{ toMacro(service_name) }}, ("%s\n", isAvailable ? "online" : "offline"));
  {{ service_name }}Manager::GetInstance()->OnAvailability(isAvailable);
}

{% for method in service.get('methods', []) %}
{% if 'for' not in method %}

Std_ReturnType SomeIp_{{ service_name }}_{{ method['name'] }}_OnResponse(uint32_t requestId, SomeIp_MessageType *res) {
  ASLOG({{ toMacro(service_name) }}, ("{{ method['name'] }} OnResponse %X: len=%d, data=[%02X %02X %02X %02X ...]\n", requestId,
                        res->length, res->data[0], res->data[1], res->data[2], res->data[3]));
  return {{ service_name }}Manager::GetInstance()->On{{ method['name'] }}Response(requestId, res);
}

Std_ReturnType SomeIp_{{ service_name }}_{{ method['name'] }}_OnError(uint32_t requestId, Std_ReturnType ercd) {
  ASLOG({{ toMacro(service_name) }}, ("{{ method['name'] }} OnError %X: %d\n", requestId, ercd));
  return {{ service_name }}Manager::GetInstance()->On{{ method['name'] }}Error(requestId, ercd);
}

{% if method.get('tp', False) %}

Std_ReturnType SomeIp_{{ service_name }}_{{ method['name'] }}_OnTpCopyRxData(uint32_t requestId, SomeIp_TpMessageType *msg) {
    return {{ service_name }}Manager::GetInstance()->On{{ method['name'] }}TpCopyRxData(requestId, msg);
}

Std_ReturnType SomeIp_{{ service_name }}_{{ method['name'] }}_OnTpCopyTxData(uint32_t requestId, SomeIp_TpMessageType *msg) {
  return {{ service_name }}Manager::GetInstance()->On{{ method['name'] }}TpCopyTxData(requestId, msg);
}

{% endif %}
{% endif %}
{% endfor %}

{% for eg in service.get('event-groups', []) %}
{% for event in eg['events'] %}
{% if 'for' not in event %}
{% if event.get('tp', False) %}

Std_ReturnType SomeIp_{{ service_name }}_{{ eg['name'] }}_{{ event['name'] }}_OnTpCopyRxData(uint32_t requestId, SomeIp_TpMessageType *msg) {
  Std_ReturnType ret = E_OK;
  static uint8_t payload[{{ GetTypePayloadSize(event, allStructs) }}];
  if ((NULL != msg) && ((msg->offset + msg->length) <= sizeof(payload))) {
    memcpy(&payload[msg->offset], msg->data, msg->length);
    if (false == msg->moreSegmentsFlag) {
      msg->data = (uint8_t *)payload;
    }
  } else {
    ret = E_NOT_OK;
  }
  return ret;
}

{% endif %}

Std_ReturnType SomeIp_{{ service_name }}_{{ eg['name'] }}_{{ event['name'] }}_OnNotification(uint32_t requestId,
                                                                    SomeIp_MessageType *evt) {

  Std_ReturnType ret = E_OK;
  int32_t serializedSize;
  static events::{{ event['name'] }}::SampleType sample;
  ASLOG({{ toMacro(service_name) }},
        ("{{ event['name'] }} OnNotification %X: len=%d, data=[%02X %02X %02X %02X ...]\n", requestId,
         evt->length, evt->data[0], evt->data[1], evt->data[2], evt->data[3]));

  serializedSize =
    {{ SomeIpXfDecode(event, allStructs, 'evt->data', 'evt->length', 'sample') }};
  if (serializedSize > 0) {
    {{ service_name }}Manager::GetInstance()->On{{ event['name'] }}(sample);
  } else {
      ASLOG({{ toMacro(service_name) }}_E, ("malformed {{ event['name'] }}\n"));
      ret = E_NOT_OK;
    }

  return ret;
}

{% endif %}
{% endfor %}
{% endfor %}

{% set eventNotifyFncs = {} %}
{% for eg in service.get('event-groups', []) %}
{% for event in eg['events'] %}
{% if 'for' not in event %}
{% if eg['name'] not in eventNotifyFncs %}
{% set _ = eventNotifyFncs.__setitem__(eg['name'], []) %}
{% endif %}
{% set _ = eventNotifyFncs[eg['name']].append('  ' ~ service_name ~ 'Manager::GetInstance()->On' ~ event['name'] ~ 'SubscribeAck(isSubscribe);') %}
{% endif %}
{% endfor %}
{% endfor %}

{% for field in service.get('fields', []) %}
{% if 'get' in field %}

Std_ReturnType SomeIp_{{ service_name }}_Get{{ field['name'] }}_OnResponse(uint32_t requestId, SomeIp_MessageType* res) {
  return {{ service_name }}Manager::GetInstance()->OnGet{{ field['name'] }}Response(requestId, res);
}

Std_ReturnType SomeIp_{{ service_name }}_Get{{ field['name'] }}_OnError(uint32_t requestId, Std_ReturnType ercd) {
  return {{ service_name }}Manager::GetInstance()->OnGet{{ field['name'] }}Error(requestId, ercd);
}

{% if field.get('tp', False) %}

Std_ReturnType SomeIp_{{ service_name }}_Get{{ field['name'] }}_OnTpCopyRxData(uint32_t requestId, SomeIp_TpMessageType *msg) {
  return {{ service_name }}Manager::GetInstance()->OnGet{{ field['name'] }}TpCopyRxData(requestId, msg);
}

Std_ReturnType SomeIp_{{ service_name }}_Get{{ field['name'] }}_OnTpCopyTxData(uint32_t requestId, SomeIp_TpMessageType *msg) {
  return {{ service_name }}Manager::GetInstance()->OnGet{{ field['name'] }}TpCopyTxData(requestId, msg);
}

{% endif %}
{% endif %}

{% if 'set' in field %}

Std_ReturnType SomeIp_{{ service_name }}_Set{{ field['name'] }}_OnResponse(uint32_t requestId, SomeIp_MessageType* res) {
  return {{ service_name }}Manager::GetInstance()->OnSet{{ field['name'] }}Response(requestId, res);
}

Std_ReturnType SomeIp_{{ service_name }}_Set{{ field['name'] }}_OnError(uint32_t requestId, Std_ReturnType ercd) {
  return {{ service_name }}Manager::GetInstance()->OnSet{{ field['name'] }}Error(requestId, ercd);
}

{% if field.get('tp', False) %}

Std_ReturnType SomeIp_{{ service_name }}_Set{{ field['name'] }}_OnTpCopyRxData(uint32_t requestId, SomeIp_TpMessageType *msg) {
  return {{ service_name }}Manager::GetInstance()->OnSet{{ field['name'] }}TpCopyRxData(requestId, msg);
}

Std_ReturnType SomeIp_{{ service_name }}_Set{{ field['name'] }}_OnTpCopyTxData(uint32_t requestId, SomeIp_TpMessageType *msg) {
  return {{ service_name }}Manager::GetInstance()->OnSet{{ field['name'] }}TpCopyTxData(requestId, msg);
}

{% endif %}
{% endif %}

{% if 'event' in field %}
{% if field['event']['groupName'] not in eventNotifyFncs %}
{% set _ = eventNotifyFncs.__setitem__(field['event']['groupName'], []) %}
{% endif %}
{% set _ = eventNotifyFncs[field['event']['groupName']].append('  ' ~ service_name ~ 'Manager::GetInstance()->On' ~ field['name'] ~ 'SubscribeAck(isSubscribe);') %}

Std_ReturnType SomeIp_{{ service_name }}_{{ field['event']['groupName'] }}_{{ field['name'] }}_OnNotification(uint32_t requestId, SomeIp_MessageType* evt) {
  return {{ service_name }}Manager::GetInstance()->On{{ field['name'] }}Notification(requestId, evt);
}

{% if field.get('tp', False) %}

Std_ReturnType SomeIp_{{ service_name }}_{{ field['event']['groupName'] }}_{{ field['name'] }}_OnTpCopyRxData(uint32_t requestId, SomeIp_TpMessageType *msg) {
  return {{ service_name }}Manager::GetInstance()->On{{ field['name'] }}TpCopyRxData(requestId, msg);
}

{% endif %}
{% endif %}

{% endfor %}

{% for groupName, fields in eventNotifyFncs.items() %}

void SomeIp_{{ service_name }}_{{ groupName }}_OnSubscribeAck(boolean isSubscribe) {
{{ fields | join('\n') }}
}

{% endfor %}

}
