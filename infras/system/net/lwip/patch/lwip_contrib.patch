diff --git a/ports/freertos/sys_arch.c b/ports/freertos/sys_arch.c
index 84bd463..2cc06a1 100644
--- a/ports/freertos/sys_arch.c
+++ b/ports/freertos/sys_arch.c
@@ -29,10 +29,11 @@
  * Author: Simon Goldschmidt <goldsimon@gmx.de>
  *
  */
-
+#define LWIP_DONT_PROVIDE_BYTEORDER_FUNCTIONS
 /* lwIP includes. */
 #include "lwip/debug.h"
 #include "lwip/def.h"
+#include "lwip/tcpip.h"
 #include "lwip/sys.h"
 #include "lwip/mem.h"
 #include "lwip/stats.h"
@@ -40,6 +41,10 @@
 #include "semphr.h"
 #include "task.h"
 
+#ifndef portTICK_RATE_MS
+#define portTICK_RATE_MS (1000u/OS_TICKS_PER_SECOND)
+#endif
+
 /** Set this to 1 if you want the stack size passed to sys_thread_new() to be
  * interpreted as number of stack words (FreeRTOS-like).
  * Default is that they are interpreted as byte count (lwIP-like).
@@ -607,3 +612,52 @@ sys_check_core_locking(void)
 }
 
 #endif /* LWIP_FREERTOS_CHECK_CORE_LOCKING*/
+
+#ifdef _WIN32
+#include <windows.h>
+
+static HCRYPTPROV hcrypt;
+void
+lwip_win32_platform_diag(const char *format, ...)
+{
+  va_list ap;
+  /* get the varargs */
+  va_start(ap, format);
+  /* print via varargs; to use another output function, you could use
+     vsnprintf here */
+  vprintf(format, ap);
+  va_end(ap);
+}
+
+static void
+sys_win_rand_init(void)
+{
+  if (!CryptAcquireContext(&hcrypt, NULL, NULL, PROV_RSA_FULL, 0)) {
+    DWORD err = GetLastError();
+    LWIP_PLATFORM_DIAG(("CryptAcquireContext failed with error %d, trying to create NEWKEYSET", (int)err));
+    if(!CryptAcquireContext(&hcrypt, NULL, NULL, PROV_RSA_FULL, CRYPT_NEWKEYSET)) {
+      char errbuf[128];
+      err = GetLastError();
+      snprintf(errbuf, sizeof(errbuf), "CryptAcquireContext failed with error %d", (int)err);
+      LWIP_UNUSED_ARG(err);
+      LWIP_ASSERT(errbuf, 0);
+    }
+  }
+}
+
+u32_t
+sys_win_rand(void)
+{
+  u32_t ret;
+  static int initialized = 0;
+  if (0 == initialized) {
+    sys_win_rand_init();
+    initialized = 1;
+  }
+  if (CryptGenRandom(hcrypt, sizeof(ret), (BYTE*)&ret)) {
+    return ret;
+  }
+  LWIP_ASSERT("CryptGenRandom failed", 0);
+  return 0;
+}
+#endif
\ No newline at end of file
diff --git a/ports/win32/include/arch/cc.h b/ports/win32/include/arch/cc.h
index cb7d500..4e9c7d4 100644
--- a/ports/win32/include/arch/cc.h
+++ b/ports/win32/include/arch/cc.h
@@ -44,10 +44,10 @@
 #if _MSC_VER >= 1910
 #include <errno.h> /* use MSVC errno for >= 2017 */
 #else
-#define LWIP_PROVIDE_ERRNO /* provide errno for MSVC pre-2017 */
+//#define LWIP_PROVIDE_ERRNO /* provide errno for MSVC pre-2017 */
 #endif
 #else /* _MSC_VER */
-#define LWIP_PROVIDE_ERRNO /* provide errno for non-MSVC */
+//#define LWIP_PROVIDE_ERRNO /* provide errno for non-MSVC */
 #endif /* _MSC_VER */
 
 /* Define platform endianness (might already be defined) */
diff --git a/ports/win32/pcapif.c b/ports/win32/pcapif.c
index e5e1ec9..b6400f3 100644
--- a/ports/win32/pcapif.c
+++ b/ports/win32/pcapif.c
@@ -497,7 +497,7 @@ pcapif_init_adapter(int adapter_num, void *arg)
   pa->input_fn_arg = arg;
 
   /* Retrieve the interfaces list */
-  if (pcap_findalldevs(&alldevs, errbuf) == -1) {
+  if (pcap_findalldevs_ex(PCAP_SRC_IF_STRING, NULL, &alldevs, errbuf) == -1) {
     free(pa);
     return NULL; /* no adapters found */
   }
@@ -705,6 +705,7 @@ pcapif_low_level_init(struct netif *netif)
 {
   u8_t my_mac_addr[ETH_HWADDR_LEN] = LWIP_MAC_ADDR_BASE;
   int adapter_num = PACKET_LIB_ADAPTER_NR;
+  const char* ENV_PACKET_LIB_ADAPTER_NR = getenv("PACKET_LIB_ADAPTER_NR");
   struct pcapif_private *pa;
 #ifdef PACKET_LIB_GET_ADAPTER_NETADDRESS
   ip4_addr_t netaddr;
@@ -712,6 +713,10 @@ pcapif_low_level_init(struct netif *netif)
   char guid[GUID_LEN + 1];
 #endif /* PACKET_LIB_GET_ADAPTER_NETADDRESS */
 
+  if (NULL != ENV_PACKET_LIB_ADAPTER_NR) {
+      adapter_num = atoi(ENV_PACKET_LIB_ADAPTER_NR);
+  }
+
   /* If 'state' is != NULL at this point, we assume it is an 'int' giving
      the index of the adapter to use (+ 1 because 0==NULL is invalid).
      This can be used to instantiate multiple PCAP drivers. */
@@ -784,7 +789,7 @@ pcapif_low_level_init(struct netif *netif)
 #if PCAPIF_RX_USE_THREAD
   pa->rx_run = 1;
   pa->rx_running = 1;
-  sys_thread_new("pcapif_rxthread", pcapif_input_thread, netif, 0, 0);
+  sys_thread_new("pcapif_rxthread", pcapif_input_thread, netif, 4096, 0);
 #endif
 
   LWIP_DEBUGF(NETIF_DEBUG, ("pcapif: eth_addr %02X%02X%02X%02X%02X%02X\n",netif->hwaddr[0],netif->hwaddr[1],netif->hwaddr[2],netif->hwaddr[3],netif->hwaddr[4],netif->hwaddr[5]));
@@ -987,6 +992,7 @@ pcapif_rx_ref(struct pbuf* p)
 }
 #endif /* PCAPIF_RX_REF */
 
+void __attribute__((weak)) PCap_Packet(const void *packet, uint32_t length) {}
 /** pcapif_input: This function is called when a packet is ready to be read
  * from the interface. It uses the function low_level_input() that should
  * handle the actual reception of bytes from the network interface.
@@ -1000,7 +1006,7 @@ pcapif_input(u_char *user, const struct pcap_pkthdr *pkt_header, const u_char *p
   struct pbuf *p;
 
   PCAPIF_RX_LOCK_LWIP();
-
+  PCap_Packet(packet, packet_len);
   /* move received packet into a new pbuf */
   p = pcapif_low_level_input(netif, packet, packet_len);
   /* if no packet could be read, silently ignore this */
